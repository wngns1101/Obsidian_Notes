이 노트는 토비의 스프링 3.1을 공부하면서 정리한 글입니다.
 
<hr>

## 1. 오브젝트와 의존관계
### 1.1 초난감 DAO
 
<hr>

#### 1. User 클래스를 만들어보자. 
	- 자바 빈 규격으로 작성한다.
	- 자바 빈이란 두 가지 관례를 따라 만들어진 오브젝트를 의미한다 
		- Default 생성자
		- 프로퍼티(Getter, Setter)

```java 
public class User {  

private String id;  
private String name;  
private String password;  
  
public String getId() {  return id;  }  
  
public void setId(String id) {  this.id = id;  }  
  
public String getName() {  return name;  }  
  
public void setName(String name) {  this.name = name;  }  
  
public String getPassword() {  return password;  }  
  
public void setPassword(String password) {  this.password = password;  }

}
```

#### 2. 사용자 정보가 보관될 테이블을 만들어보자.
``` mysql
create table users{
	id varchar(10) primary key,
	name varchar(20) not null,
	password varchar(10) not null
}
```

#### 3. 사용자 정보를 DB에 넣어 관리할 수 있는 DAO 클래스를 만들어보자.
	-  add와 get 먼저 만들어보도록 한다.

``` java
public void add(User user) throws ClassNotFoundException, SQLException {  
	 Class.forName("com.mysql.cj.jdbc.Driver");  
	 Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "?");  
  
	PreparedStatement ps = c.prepareStatement("insert into user(id, name, password) values (?, ?, ?)");  
  
	ps.setString(1, user.getId());  
	ps.setString(2, user.getName());  
	ps.setString(3, user.getPassword());  
  
	ps.executeUpdate();  
  
	ps.close();  
	c.close();  
}  
  
public User get(String id) throws ClassNotFoundException, SQLException {  
	 Class.forName("com.mysql.cj.jdbc.Driver");  
	 Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "?");  
	  
	PreparedStatement ps = c.prepareStatement("select * from user where id = ?");  
	  
	ps.setString(1, id);  
	  
	ResultSet resultSet = ps.executeQuery();  
	resultSet.next();  
	  
	User user = new User();  
	user.setId(resultSet.getString("id"));  
	user.setName(resultSet.getString("name"));  
	user.setPassword(resultSet.getString("password"));  
	  
	resultSet.close();  
	ps.close();  
	c.close();  
	  
	return user;  
}
```

#### 4. main()을 이용해서 테스트를 해보자
   
``` java
public class Obsidian{
	public static void main(String[] args) throws SQLException, ClassNotFoundException {  
	
	SpringApplication.run(TobiSpringV1Application.class, args);  
 
	UserDao dao = new UserDao();  
    
	User user = new User();  
	user.setId("4");  
	user.setName("5");  
	user.setPassword("6");  
  
	dao.add(user);  
  
	System.out.println(nUser.getId() + " 등록 성공!");  
  
	User user2 = dao.get(user.getId());  
	System.out.println(user2.getName());  
	System.out.println(user2.getPassword());  
	  
	System.out.println(user2.getId() + " 조회 성공");  
	}
}
```

> 여기까지만 무리없이 작성했으면 기본적인 DAO와 테스트는 완성했다 하지만 객체지향의 세계에서는 모든 것이 변한다. 
> 요구사항은 끊임없이 바뀌고 시술도 시간이 지남에 따라 바뀐다. 따라서 미래의 변화를 대비하면서 코드를 작성해야한다.
> 변화를 대비한다는 것은 변화의 폭을 최소한으로 줄여주는 것이다. 다음 챕터부터 하나씩 바꾸어보자.

### 1.2 DAO 분리

<hr>

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
변화가 한 번에 한 가지 관심사항에 집중해서 일어난다면 우리는 한 가지 관심이 한 가지에 집중되게 해야한다.
이를 관심사의 분리라고 한다.

> 관심사의 분리라는 것은 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 보이게 하고 관심이 다른 객체는 가능한 한 따로 떨어져서 분리하는 것이라고 한다.

#### 1. UserDao의 관심사항
현재 UserDao에서 가장 문제가 되는 것은 DBConnection을 가져오는 부분이 get, add 메서드에서 중복되어 있다는 것이다. 
가장 먼저 할 일은 중복된 코드를 분리하는 것이다.
중복된 DB 연결 코드를 메서드로 분리한다.
``` java
public void add(User user) throws ClassNotFoundException, SQLException {  
	// 초난감 상태  
	// Class.forName("com.mysql.cj.jdbc.Driver");  
	// Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "Wkrwjs4602!");  
	  
	Connection c = getConnection(); 
	 
	PreparedStatement ps = c.prepareStatement("insert into user(id, name, password) values (?, ?, ?)");  
	  
	ps.setString(1, user.getId());  
	ps.setString(2, user.getName());  
	ps.setString(3, user.getPassword());  
	  
	ps.executeUpdate();  
	  
	ps.close();  
	c.close();  
}  
  
public User get(String id) throws ClassNotFoundException, SQLException {  
	// 초난감 상태    
	// Class.forName("com.mysql.cj.jdbc.Driver");  
	// Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "Wkrwjs4602!");  
	  
	Connection c = getConnection();  
	  
	PreparedStatement ps = c.prepareStatement("select * from user where id = ?");  
	  
	ps.setString(1, id);  
	  
	ResultSet resultSet = ps.executeQuery();  
	resultSet.next();  
	  
	User user = new User();  
	user.setId(resultSet.getString("id"));  
	user.setName(resultSet.getString("name"));  
	user.setPassword(resultSet.getString("password"));  
	  
	resultSet.close();  
	ps.close();  
	c.close();  
	  
	return user;  
	}  
	  
	public  Connection getConnection() throws ClassNotFoundException, SQLException{
		Class.forName("com.mysql.cj.jdbc.Driver");  
  
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "Wkrwjs4602!");  
  
		return c;
	}  
}
```

#### 2. DB Connection 만들기의 독립
DBConnection을 가져오는 것을 메서드 추출을 함으로서 유연하게 대처할 수 있는 코드를 만들었다.
이번에는 DAO를 변화에 유동적으로 만들어보자.

현재 getConnection은 한 가지의 연결 정보로 고정이 되어있다.
하지만 여러개의 데이터베이스에 관한 연결 정보를 써야할 때는 문제가 생긴다.
따라서 getConnection 메서드를 추상 클래스로 변형할것이다.


``` java
public void add(User user) throws ClassNotFoundException, SQLException {  
	...
}  
  
public User get(String id) throws ClassNotFoundException, SQLException {  
	...
}
	  
public  abstract Connection getConnection() throws ClassNotFoundException, SQLException;
  
}
public class NUserDao extends UserDao {  
	@Override  
	public Connection getConnection() throws ClassNotFoundException, SQLException {  
	Class.forName("com.mysql.cj.jdbc.Driver");  
	  
	Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "?");  
	  
	return c;  
	}  
}
public class DUserDao extends UserDao {  
  
@Override  
	public Connection getConnection() throws ClassNotFoundException, SQLException {  
	Class.forName("com.mysql.cj.jdbc.Driver");  
	  
	Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "?");  
	  
	return c;  
	}  
}
```

클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리되면서 변경 작업은 한층 용이해졌다.
이처럼 슈퍼클래스에 기본적인 로직의 흐름을 만들고 서브클래스에서 이를 필요에 맞게 구현해서 사용하는 방법을 <b>템플릿 메서드 패턴</b> 이라고 한다.

> 이렇게 디자인 패턴을 활용해 관심사를 분리해내면서 코드를 확장시켰다. 하지만 이 방법은 단점이있다.
> 상속은 단일 상속만 가능하다는 것이다. 이미 다른 객체를 상속하고 있었다면 이 방법으로 적용하기는 힘들다.
> 또 하나의 단점은 밀접하게 연관되어있다는 점이다. 서브 클래스는 슈퍼 클래스의 기능을 직접 사용할 수 있기 때문에  슈퍼 클래스의 코드가 변경된다면 서브 클래스의 코드도 변경해야하는 우려가 있다. 



### 1.3 DAO 확장
<hr>

이번에는 관심사가 다르고 변화의 성격이 다른 코드들을 화끈하게 분리하도록 한다.
#### 1. SimpleConnectionMaker 클래스 생성
``` java
public class SimpleConnectionMaker {  
	public Connection makeNewConnection() throws ClassNotFoundException, SQLException {  
	Class.forName("com.mysql.cj.jdbc.Driver");  
	  
	Connection c = DriverManager.getConnection("jdbc:mysql://localhost/user", "root", "Wkrwjs4602!");  
	  
	return c;  
	}  
}
```

#### 2. UserDao 클래스 수정
``` java
private SimpleConnectionMaker simpleConnectionMaker;
	
public UserDao(ConnectionMaker connectionMaker) {  
	 simpleConnectionMaker = new SimpleConnectionMaker();  
}

public void add(User user) throws ClassNotFoundException, SQLException {
	Connection c = simpleConnectionMaker.makeNewConnection()
}

public User get(String id) throws ClassNotFoundException, SQLException {
	Connection c = simpleConnectionMaker.makeNewConnection()
}

}
```

이 리펙토링을 함으로서 좀 더 나은 코드로 바뀌었지만 다른 문제가 발생했다. N사와 D사에서 상속을 통해 커넥션 기능을 확장해서 사용하게 했던 것이 다시 불가능해졌다. 
UserDao가 SimpleConnectionMaker에 종속됨으로서 상속을 사용했을 때처럼 커넥션 생성을 변경할 방법이 없어졌다.
따라서 인터페이스를 도입하도록 하자.

> 인터페이스는 자바가 추상화를 위해 제공하는 가장 유용한 도구이다.

인터페이스는 어떤 일을 하겠다는 기능만 정의한 것이기 때문에 기능을 어떻게 구현했는지에 대한 관심은 둘 필요가 없다.

#### 3. ConnectionMaker 정의
	
``` java
public interface ConnectionMaker {  
public Connection makeConnection() throws ClassNotFoundException, SQLException;  
}
```

#### 4. UserDao 수정
	UserDao 생성자를 인터페이스 변수로 사용하면서 객체지향의 다형성을 적용시켰다. 	

``` java
public class UserDao {  
private ConnectionMaker connectionMaker;  
  
 public UserDao(ConnectionMaker connectionMaker) {  
	this.connectionMaker = connectionMaker;  
 }  
  
public void add(User user) throws ClassNotFoundException, SQLException {  
  
Connection c = connectionMaker.makeConnection();  

PreparedStatement ps = c.prepareStatement("insert into user(id, name, password) values (?, ?, ?)");  
  
ps.setString(1, user.getId());  
ps.setString(2, user.getName());  
ps.setString(3, user.getPassword());  
  
ps.executeUpdate();  
  
ps.close();  
c.close();  
}  
  
public User get(String id) throws ClassNotFoundException, SQLException {  
Connection c = connectionMaker.makeConnection();  
  
PreparedStatement ps = c.prepareStatement("select * from user where id = ?");  
  
ps.setString(1, id);  
  
ResultSet resultSet = ps.executeQuery();  
resultSet.next();  
  
User user = new User();  
user.setId(resultSet.getString("id"));  
user.setName(resultSet.getString("name"));  
user.setPassword(resultSet.getString("password"));  
  
resultSet.close();  
ps.close();  
c.close();  
  
return user;  
}  
```

#### 5. main 메서드
``` java

@SpringBootApplication  
public class TobiSpringV1Application {  
  
public static void main(String[] args) throws SQLException, ClassNotFoundException {  
SpringApplication.run(TobiSpringV1Application.class, args);  

ConnectionMaker connectionMaker = new NConnectionMaker();  
UserDao nDao = new UserDao(connectionMaker);  

User nUser = new User();  
nUser.setId("4");  
nUser.setName("5");  
nUser.setPassword("6");  
  
nDao.add(nUser);  
  
System.out.println(nUser.getId() + " 등록 성공!");  
  
User user2 = nDao.get(nUser.getId());  
System.out.println(user2.getName());  
System.out.println(user2.getPassword());  
  
System.out.println(user2.getId() + " 조회 성공");  
}  
  
}
```

이렇게 상속을 통한 확장을 인터페이스로 바꾸면서 필요에 따라 자유롭게 확장할 수 있는 구조로 변경했다.

지금까지는 객체지향의 5원칙중 하나인 개방 폐쇄 원칙으로 리펙토링을 진행했다.

> 개방 폐쇄 원칙이란 클래스나 모듈은 확장에는 열려 있어야하지만 변경에는 닫혀 있어야 한다는 것이다.

예를 들어 UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려있다. 동시에 UserDao의 핵심 기능을 구현한 코드는 변화에 영향을 받지 않고 유지할 수 있음으로 변경에는 닫혀 있다고 말할 수 있다.

지금 현재 UserDaoTest - UserDao - ConnectionMaker 구조를 전략 패턴이라고 한다.

> 전략 패턴이란 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

UserDao는 전략 패턴의 컨텍스트에 해당하며 기능을 수행하는데 변경이 가능한 부분 즉 DB 연결 부분을 인터페이스로 분리해 이를 구현한 클래스 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

### 1.4 오브젝트 팩토리
<hr>

1.3까지의 과정을 통해 깔끔한 코드로 리펙토링을 하는 과정을 수행했다. 하지만 그 과정에서 빠트린 것이 있다.
바로 클라이언트인 UserDaoTest이다.
UserDaoTest는 UserDao가 담당하던 구현 클래스를 결정하는 기능을 떠맡았다.  성격이 다른 관심은 분리하자.

#### 1. 팩토리 클래스 생성
> 팩토리란 객체의 생성 방법을 결정하고 만들어진 오브젝트를 리턴하는 역할을 한다.

UserDao에서 Connection 생성 방법을 DaoFactory에 옮긴다. 
UserDaoTest는 DaoFactory에 요청해서 오브젝트를 가져와 사용한다.

``` java
public class DaoFactory {  

	public UserDao UserDao() {  
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);  
		return userDao;  
	}

}
```


#### 2. 메인 메서드 수정
``` java
public class TobiSpringV1Application {  
  
public static void main(String[] args) throws SQLException, ClassNotFoundException {  
	SpringApplication.run(TobiSpringV1Application.class, args);  
	 UserDao dao = new DaoFactory().userDao();
}
```


그러나 위에 있는 코드는 중복이 ㅂ라생한다는 우려가 있다. 
UserDao가 아닌 AccountDao, MessageDao 메서드를 새로 만들었을 때 ConnectionMaker 클래스가 중복이 된다. 
중복되는 것은 분리하는게 가장 좋은 방법이다 ConnectionMaker를 별도의 메서드로 뽑아내자

#### 3. UserDao 메서드 추가
``` java 
public class DaoFactory {  

	public UserDao UserDao() {  
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);  
		return userDao;  
	}
	public ConnectionMaker connectionMaker() {  
return new DConnectionMaker();  
}
}
```

### 1.5 스프링의 IoC
<hr>

이제 지금까지의 과정을 거친 DaoFactory를 스프링에서 사용이 가능하도록 변신시켜보자.

> 스프링에서는 스프링이 제어권을 가지고 생성하는 객체를 <b>빈</b>이라고 한다.
> 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 펙토리라고 부른다.
> 사실상 빈 펙토리를 확장한 애플리케이션 컨텍스트를 많이 쓴다.

#### 1. 애노테이션 추가
	유저 펙토리 안에 애노테이션을 추가한다.
	
	``` java

	@Configuration // 애플리케이션 컨텍스트 또는 빈 펙토리가 사용할 설정정보라는 표시  
	public class DaoFactory {  
		@Bean // 오브젝트 생성을 담당하는 ioC용 메소드라는 표시  
		public UserDao UserDao() {  
			return new UserDao(connectionMaker())
		}
		@Bean  
		public ConnectionMaker connectionMaker() {  
			return new DConnectionMaker();  
		}
	}
	```

#### 2. UserDaoTest 메서드 수정
	@Configure 애노테이션이 붙은 자바 코드를 설정코드로 사용하려면 AnnotationConfigApplicationContext 클래스를 이용하면 된다.
	getBean 메서드는 context에 등록된 빈의 이름이다.
``` java
public class UserDaoTest {  
public static void main(String[] args) throws ClassNotFoundException, SQLException {  
	ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);  
	UserDao userDao1 = context.getBean("UserDao", UserDao.class);  
	System.out.println(userDao2);  
}
```



그래서 스프링으로 구현한 것과 자바로 구현한것의 차이가 무엇이냐고 한다면  이는 작동 방식에 있다. 스프링은 설정을 하지 않으면 기본적으로 싱글톤으로 구현한다.

이는 자바에서는 객체를 new로 생성하면 다른 주소의 값을 리턴하지만 싱글톤에서는 한 번만 만들고 만들어진 클래스를 공유해서 사용하기 때문에 차이점이 보인다.  
### 1.7 의존관계 주입(DI)
IoC는 매우 느신하게 정의 되어서 폭넓게 사용되는 용어이다. 따라서 몇몇 사람의 제안으로 의존관계 주입(DI)라는 이름을 사용하기 시작했다.
지금까지 UserDao는 ConnectionMaker에 의존했다. ConnectionMaker가 변하면 UserDao는 그 영향을 직접적으로 받았다. 하지만 DConnectionMaker 즉 ConnectionMaker를 구현한 클래스는 변화가 생겨도 UserDao에 영향을 주지 않는다. 
의존관계란 한 쪽에 영향을 주는 것이라고 했으니 인터페이스를 사용하면 변경에서 자유롭게 할 수 있다.
의존관계주입은 의존 오브젝트(실제 사용대상 클래스)와 그것을 사용할 주체(클라이언트)를 런타임 시에 연결해주는 것을 말한다.

현재 UserDao의 생성자는 DConnectionMaker()로 관리되고 있다. 이미 의존관계가 코드에서 정의되어 있기 때문에 IoC 방식을 써서 코드를 제거하고 의존관계 결정 권한을 위임할 것이다.

#### 1. 생성자 변경
``` java
	public class UserDao {  
	
	private ConnectionMaker connectionMaker;
	
	public UserDao(ConnectionMaker connectionMaker) {  
		this.connectionMaker = connectionMaker;  
	}
```

이렇게 DI 컨테이너에 의해 런타임 시에 의존 프로젝트를 사용할 수 있도록 레퍼런스를 전달받는 과정이 
마치 메서드를 통해 UserDao에게 주입해주는 것과 같다고 해서 이를 의존관계 주입이라고 한다.

의존관계 주입은 생성자 뿐만이 아닌 메서드 부분에서도 가능하기 때문에 참고하도록 하자.

### 1.8 XML을 이용한 설정
스프링은 DaoFactory와 같은 자바 클래스를 이용하는 것 외에도 다양한 방법을 통해 설정정보를 만들 수 있다.
가장 대표적인 것이 XML이다. 
@Configuration은 beans @Bean은 bean으로 대응해서 생각하면 이해하기 편할 것이다. 

#### 1. xml 설정
``` xml
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans"  
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">  
  
<bean id="connectionMaker" class="com.example.tobi_spring_v1.dao.DConnectionMaker"/>  
<bean id="userDao" class="com.example.tobi_spring_v1.dao.UserDao">  
<property name="connectionMaker" ref="connectionMaker"/>  
</bean>  
</beans>
```

#### 2. main 메서드 수정
	xml로부터 문서를 가져오는 방법은 GenericXmlApplicationContext를 사용하면 된다.
``` java
public class UserDaoTest {  
	public static void main(String[] args) throws ClassNotFoundException, SQLException {  
	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
	UserDao userDao1 = context.getBean("userDao", UserDao.class);  
	System.out.println(userDao1);  
	}  
}
```

#### 3. DataSource 인터페이스 적용
	실전에서는 커넥션을 가져오는 방법을 정의한 DataSource 인터페이스가 많기 때문에 정의를 직접 하지는 않는다.
	스프링이 제공해주는 테스트 환경에서 간단히 사용할 수 있는 SimpleDriverDataSource라는 것이 있다.
	기존에 DaoFactory에서 사용하던 connectioinMaker() 메소드를 dataSource()로 변경 후 SimpleDriverDataSource()로 리턴한다.
	추가로 생성자에 있던 userDao에 dataSource()를 주입한다.
	
``` java
package com.example.tobi_spring_v1.dao;  
  
// 객체의 생성 방법을 결정하고 그로 만들어진 오브젝트를 돌려주는 것을 factory라고 부른다  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.jdbc.datasource.SimpleDriverDataSource;  
  
import javax.sql.DataSource;  
  
@Configuration // 애플리케이션 컨텍스트 또는 빈 펙토리가 사용할 설정정보라는 표시  
public class DaoFactory {  
	@Bean // 오브젝트 생성을 담당하는 ioC용 메소드라는 표시  
	public UserDao UserDao() {  
		UserDao userDao = new UserDao();  
		userDao.setDataSource(dataSource());  
		return userDao;  
	}  
  
	@Bean  
	public DataSource dataSource() {  
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();  
		  
		dataSource.setDriverClass(com.mysql.cj.jdbc.Driver.class);  
		dataSource.setUrl("jdbc:mysql://localhost/user");  
		dataSource.setUsername("root");  
		dataSource.setPassword("wkrwjs4602!");  
		  
		return dataSource;  
	}  
}
```

#### 4. UserDao 수정
	기존에 주입하던 ConnectionMaker에서 DataSource로 변경한다.
``` java
public class UserDao {  
	private DataSource dataSource;  
  
	public void setDataSource(DataSource dataSource) {  
	this.dataSource = dataSource;  
	}   
  
	public void add(User user) throws ClassNotFoundException, SQLException {  
	Connection c = dataSource.getConnection();  
	PreparedStatement ps = c.prepareStatement("insert into user(id, name, password) values (?, ?, ?)");  
	  
	ps.setString(1, user.getId());  
	ps.setString(2, user.getName());  
	ps.setString(3, user.getPassword());  
	  
	ps.executeUpdate();  
	  
	ps.close();  
	c.close();  
	}  
  
	public User get(String id) throws ClassNotFoundException, SQLException {  
	Connection c = dataSource.getConnection();  
	  
	PreparedStatement ps = c.prepareStatement("select * from user where id = ?");  
	  
	ps.setString(1, id);  
	  
	ResultSet resultSet = ps.executeQuery();  
	resultSet.next();  
	  
	User user = new User();  
	user.setId(resultSet.getString("id"));  
	user.setName(resultSet.getString("name"));  
	user.setPassword(resultSet.getString("password"));  
	  
	resultSet.close();  
	ps.close();  
	c.close();  
	  
	return user;  
	}
}
```

#### 5. xml 방식 변경
DataSource로 변환한 것을 이번에는 xml 문서를 통해 수정해보겠다.
property를 통해 수정자 메서드에 필요한 내용을 작성한 후 값을 주입한다.

``` xml
<?xml version="1.0" encoding="UTF-8"?>  
	<beans xmlns="http://www.springframework.org/schema/beans"  
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">  
	    
	<bean id="userDao" class="com.example.tobi_spring_v1.dao.UserDao">  
	<property name="dataSource" ref="dataSource"/>  
	</bean>  
	  
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">  
	<property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>  
	<property name="url" value="jdbc:mysql://localhost/user"/>  
	<property name="username" value="root"/>  
	<property name="password" value="Wkrwjs4602!" />  
	</bean>  
</beans>
```

#### 6. main 메서드 변경
``` java
public class UserDaoTest {  
	public static void main(String[] args) throws ClassNotFoundException, SQLException {  
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
		UserDao userDao1 = context.getBean("userDao", UserDao.class);  
		System.out.println(userDao1);  
		User user = userDao1.get("1");  
		System.out.println(user.getId());  
	}  
}
```
### 1.9 정리
<hr>

1장에서는 간단한 사용자 정보를 등록하고 조회하는 간단한 DAO 코드를 작성했다. 그 코드의 문제점을 다양한 방법과 패턴, 원칙으로 분리하고 IoC/DI 프레임워크까지 적용해서 개선했다.

- 먼저 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다.(관심사의 분리, 리펙토링)
- 바뀔 가능성이 있는 클래스는 인터페이스를 구현 후 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도 그 기능을 사용하는 클래스의 코드는 수정할 필요가 없도록 만들었다. (전략 패턴)
- 이를 통해 확장은 자유롭게 하지만 불필요한 변화가 발생하지 않도록 막아주게 만들었다.(개방 폐쇄 원칙)
- 별로의 오브젝트 팩토리를 만들어 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어줬다.
- 싱글톤 패턴 구현 방식의 단점을 살펴보고 장점을 살리면서 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다.
- 클래스와 인터페이스 사이에는 느슨한 관계만 만들어놓고 런타임 시에 구체적인 의존 클래스를 DI의 도움으로 주입받아서 다이내믹한 의존관계를 갖게 해주는 케이스를 알아봤다.
- 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메소드를 이용하는 방법을 알아봤다.
- XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반 값을 런타임 시에 주입하는 방법을 알아봤다.
## 2. 테스트
<hr>

+ 1장에서 만든 UserDao가 기대하는 대로 동작하는지 간단한 테스트 코드를 만들었다.
+ 이전에 만든 테스트 코드는 UserDao의 get, add를 호출하고 출력해 테스트했다.
+ 테스트를 작성한 덕분에 적용한 기술이 변경되더라도 잘 수행한다는 것을 테스트 할 수 있었다.

테스트를 진행하면서 코드의 결함을 제거하며, 일명 디버깅을 거치게 되고 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.
### 1. UserDaoTest 다시보기
<hr>

#### 1. main()으로 작성된 테스트

``` java
package com.example.tobi_spring_v1;  
  
import com.example.tobi_spring_v1.dao.UserDao;  
import com.example.tobi_spring_v1.domain.User;  
import org.springframework.context.ApplicationContext;  
import org.springframework.context.support.GenericXmlApplicationContext;  
  
import java.sql.SQLException;  
public class UserDaoTest {  
  
public static void main(String[] args) throws ClassNotFoundException, SQLException {  
	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
	UserDao userDao1 = context.getBean("userDao", UserDao.class);  
	  
	User user = new User();  
	user.setId("user");  
	user.setName("dlwngns");  
	user.setPassword("java");  
	  
	userDao1.add(user);  
	  
	System.out.println(user.getId() + "등록 성공!");  
	  
	User user1 = userDao1.get(user.getId());  
	System.out.println(user1.getName());  
	System.out.println(user1.getPassword());  
	System.out.println(user1.getId() + "조회 성공");  
	}  
}
```

main() 메서드를 이용해 쉽게 테스트릴 진행했다는 점과 UserDao를 직접 호출해서 사용한다는게 돋보인다.

+ 테스트 코드를 따로 만들어야 하는 이유
> 웹 프로그램에서 DAO를 테스트 한다는 것은 에플리케이션을 서버를 통해 띄워서 직접 하나하나 테스트를 진행하는데 이는 단점이 너무 많다.
> 1. 기능을 다 만들어야 테스트가 가능하다.
> 2. 테스트를 하는 중에 에러가 난다면 문제발생지를 찾아야 하는 수고가 발생한다.
> 3. 하나의 테스트를 하기 위해 여러 설정이 묶여있다.

테스트하고자 하는 대상이 명확하다면 하나만 집중해서 테스트하는게 바람직하다.
이렇게 작은 단위의 코드에 테스트를 수행하는 것을 <b>단위 테스트</b>라고 한다.

+ 단위 테스트를 해야하는 이유
> 개발자 스스로 코드가 원래 의도한 대로 동작하는지 빨리 확인받기 위해서다.
> 이를 <b>개발자 테스트</b> 또는 <b>프로그래머 테스트</b>라고 한다.

테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보단ㄴ 별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다.

+ UserDao의 장점
> 1. 자주 반복 가능(테스트 간단하게 가능)
> 2. 빠른 테스트 가능(서버를 실행해서 테스트 하는 것보다 빠른 응답속도)

+ UserDao의 단점
>1. 수동 확인 작업의 번거로움(개발자가 직접 테스트가 성공했는지 확인해야 함)
>2. 실행 작접의 번거로움(main 메서드가 많아질 경우 직접 테스트를 실행해야 함)

### 2. UserDaoTest 개선
<hr>

#### 1. 테스트 검증의 자동화
<hr>

첫번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어보자.
이전에 출력하던 조회 성공 메시지는 get() 메서드가 에러 없이 끝났다는 의미 뿐 조회 테스트가 모두 성공했다는 뜻은 아니었다.

``` java
System.out.println(user1.getName());  
System.out.println(user1.getPassword());  
System.out.println(user1.getId() + "조회 성공");
```

이 코드를 다음 과 같이 수정한다.

``` java
if (!user.getName().equals(user1.getName())) {  
System.out.println("테스트 실패 (name)");  
} else if (!user.getPassword().equals(user1.getPassword())) {  
System.out.println("테스트 실패 (password)");  
}else{  
System.out.println("조회 테스트 성공!");  
}
```


#### 2. JUnit 테스트로 전환
<hr>

편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 main() 메서드로는 한계가 있다. 그에 맞는 테스트 도구와 테스트 작성 방법이 필요하다.
자바에는 단순한 실용적인 테스트를 위한 도구가 존재하는데 이를 <b>JUnit</b>이라고 한다.

main 메서드를 Junit 테스트로 전환

``` java
@SpringBootTest  
public class UserDaoTest {  

	@Test  
	public void addAndGet() throws SQLException, ClassNotFoundException {  
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
		UserDao userDao = context.getBean("userDao", UserDao.class);

		User user = new User();  
		user.setId("user");  
		user.setName("dlwngns");  
		user.setPassword("java");

		userDao.add(user);  
		  
		User userGet1 = userDao.get(user1.getId());  
		assertThat(userGet1.getId()).isEqualTo(user1.getId());  
		assertThat(userGet1.getPassword()).isEqualTo(user1.getPassword());  
	}  
}  
```

### 3. 개발자를 위한 테스팅 프레임워크 JUnit
<hr>

스프링을 제대로 활용하려면 최소한의 JUnit 테스트 작성 방법과 실행 방법은 알고 있어야 한다.
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.

지금까지 테스트를 진행하면서 가장 불편했던 일은, 매번 UserDaoTest 테스트를 실행하기 전에 DB에 User 데이터를 모두 삭제해줘야 할 때였다. 이는 좋은 테스트라 할 수 없다. 

코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

UserDao에 삭제와 레코드 개수를 위한 메서드를 두 개 추가한다
``` java

public void deleteAll() throws SQLException{  
	Connection c = dataSource.getConnection();  
	  
	PreparedStatement ps = c.prepareStatement("delete from user");  
	  
	ps.executeUpdate();  
	  
	ps.close();  
	c.close();  
}  
  
public int getCount() throws SQLException {  
	Connection c = dataSource.getConnection();  
	  
	PreparedStatement ps = c.prepareStatement("select count(*) from user");  
	  
	ResultSet rs = ps.executeQuery();  
	rs.next();  
	int count = rs.getInt(1);  
	  
	rs.close();  
	ps.close();  
	c.close();  
	  
	return count;  
}

```

각각의 메서드는 독립적으로 사용하기는 애매하기 때문에 기존에 만들었던 addAndGet 메서드에서 테스트를 확장해서 사용해야한다.

deleteAll을 사용한 직후는 count가 0, user를 추가한 후에는 1개씩 증가해야 하기 때문에 이것도 검증한다.

``` java

@Test  
public void addAndGet() throws SQLException, ClassNotFoundException {  
	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
	UserDao userDao = this.context.getBean("userDao", UserDao.class);
	
	User user1 = new User("ee", "kk", "jj");  
	User user2 = new User("aa", "cc", "ee");  

	userDao.deleteAll();  
	assertThat(userDao.getCount()).isEqualTo(0);  
	  
	userDao.add(user1);  
	userDao.add(user2);  
	  
	assertThat(userDao.getCount()).isEqualTo(2);  
	  
	User userGet1 = userDao.get(user1.getId());  
	assertThat(userGet1.getId()).isEqualTo(user1.getId());  
	assertThat(userGet1.getPassword()).isEqualTo(user1.getPassword());  
	  
	User userGet2 = userDao.get(user2.getId());  
	assertThat(userGet2.getId()).isEqualTo(user2.getId());  
	assertThat(userGet2.getPassword()).isEqualTo(user2.getPassword());  
  
}

```

getCount()에 대한 좀 더 꼼꼼한 테스트를 만들기 위해 메서드를 추가한다.

``` java 

@Test  
public void count() throws SQLException, ClassNotFoundException {  

	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
	UserDao userDao = this.context.getBean("userDao", UserDao.class);
	
	User user1 = new User("ee", "kk", "jj");  
	User user2 = new User("aa", "cc", "ee");  
	User user3 = new User("bb", "dd", "ff");
	
	userDao.deleteAll();  
	assertThat(userDao.getCount()).isEqualTo(0);  
	  
	userDao.add(user1);  
	assertThat(userDao.getCount()).isEqualTo(1);  
	  
	userDao.add(user2);  
	assertThat(userDao.getCount()).isEqualTo(2);  
	  
	userDao.add(user3);  
	assertThat(userDao.getCount()).isEqualTo(3);  
}

```

추가로 get()를 호출했을 때 id에 해당되는 값이 없을 때 예외를 반환하는 메서드를 추가한다.

``` java

@Test  
public void getUserFailure() throws SQLException {  
	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
	UserDao userDao = this.context.getBean("userDao", UserDao.class);

	userDao.deleteAll();  
	assertThat(userDao.getCount()).isEqualTo(0);  
	  
	assertThrows(EmptyResultDataAccessException.class, () -> {  
	userDao.get("unknown_id");  
	});  
}

```

테스트에 맞게 get() 메서드를 수정한다.

``` java

User user = null;  
if (resultSet.next()) {  
user = new User();  
user.setId(resultSet.getString("id"));  
user.setName(resultSet.getString("name"));  
user.setPassword(resultSet.getString("password"));  
}  
  
resultSet.close();  
ps.close();  
c.close();  
  
if (user == null) throw new EmptyResultDataAccessException(1);  
  
return user;

```

개발자는 머릿속으로 코드가 잘 돌아가는 케이스를 상상하면서 코드를 만든다.
따라서 테스트를 작성할 때도 잘 돌아가게 하기 위해 문제가 될 만한 코드를 교묘하게 . 잘피해서 코드를 만드는 습성이 있다.
그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

지금까지 우리는 존재하지 않는 Id로 get()을 실행하면 에외를 던져야한다. 라는 식으로 테스트 코드를 작성했다 그리고 나서 UserDao 코드를 수정했는데 이처럼 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 <b>테스트 주도 개발</b>이라고 한다.

코드를 만들고 나서 시간이 지나면 테스트를 만들기 귀찮아지기 떄문에 만들더라도 성의 없는 테스트를 만들게 될지도 모른다.

가능한 주기를 짧게 최대한 많은 테스트를 작성하는게 좋다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다.

중복된 코드는 별도의 메소드로 뽑아내는 것이 가장 손쉬운 방법이다.
Test가 실행되기 전에 먼저 실행한다는 의미인 @Before 어노테이션을 활용하자

``` java
 
... 
@SpringBootTest  
public class UserDaoTest {  
	@Autowired  
	private UserDao dao;  
	  
	@BeforeEach  
	public void setUp() {  
		 ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");  
		 this.userDao = this.context.getBean("userDao", UserDao.class);  
	}  
	  
	@Test  
	public void addAndGet() throws SQLException, ClassNotFoundException {  
		...
	}  
	  
	@Test  
	public void count() throws SQLException, ClassNotFoundException {  
		... 
	}  
	  
	@Test  
	public void getUserFailure() throws SQLException {  
		...  
	}  
}

```

+ JUnit 테스트를 수행하는 방식
> 1. 테스트 클래스에서 @Test가 붙은 public void 메서드를 모두 찾는다.
> 2. 테스트 클래스의 오브젝트 하나 생성한다.
> 3. @Before 메서드가 있으면 실행한다.
> 4. @Test가 붙은 메서드를 하나 호출하고 결과를 저장한다.
> 5. @After가 붙은 메서드가 있으면 실행한다.
> 6. 나머지 테스트 메서드에 대해 2~5번을 반복한다.
> 7. 모든 결과를 종합해서 돌려준다.

+ 메서드를 실행할 때마다 새로운 오브젝트 만드는 이유
> 각각 독립적으로 테스트를 실행함을 보장해주기 위해 새로운 오브젝트를 만들게 함

테스트를 수행하는데 필요한 정보나 오브젝트를 <b>픽스처</b>라고 한다. 
픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메서드를 이용해 생성해주면 편리하다. 예를 들면(UserDaoTest의 경우 dao)

User 메서드의 경우도 픽스처라고 할 수 있다. getUserFailure() 테스트에서는 User를 안 쓰지만 앞으로 테스트가 확장되면서 User에 관련된 메서드는 대부분 User 오브젝트를 사용하기 때문에 @Before 메서드에 정의한다.

``` java

public class UserDaoTest {  

private UserDao userDao;  
private User user1;  
private User user2;  
private User user3;  
  
@BeforeEach  
public void setUp() {  
	...
	this.user1 = new User("ee", "kk", "jj");  
	this.user2 = new User("aa", "cc", "ee");  
	this.user3 = new User("bb", "dd", "ff");  
}

```


### 4. 스프링 테스트 적용
<hr>

4까지의 과정을 진행하면서 테스트 코드도 어느 정도 깔끔하게 정리됐다. 하지만 아직 찜찜한 부분이 남아있는데 애플리케이션 컨텍스트 생성 방식이다. @Before 메서드가 각각의 테스트마다 적용되기 때문에 컨텍스트도 메서드의 개수만큼 만들어진다.

오브젝트 컨텍스트가 만들어질 떄는 모든 싱글톤 오브젝트를 초기화하는데 빈 오브젝트를 만드는 정도라면 상관없지만, 어떤 빈은 생성되면서 바로 초기화되기 때문에 성능저하의 오류가 있다.

테스트난 가능한 독립적으로 사용하는 것이 원칙이지만 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.

Junit이 지원하는 @BeforeClass 어노테이션이 있지만 스프링이 제공하는 기능을 사용하는 것이 더 편리하다.

``` java
@ContextConfiguration(locations = "/test-applicationContext.xml")  
@SpringBootTest  
public class UserDaoTest {  
	@Autowired
	private ApplicationContext context;
	  
	@BeforeEach  
	public void setUp() {  
		this.userDao = this.context.getBean("userDao", UserDao.class);  
		...
	}
```

@ContextConfiguration을 사용하면 자동으로 설정파일 위치를 지원한다.

@Autowried가 붙은 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하면 인스턴스 변수에 주입해준다.
일반적으로는 생성자나 수정자 메서드가 필요하지만 이 경우에는 자동와이어링으로 주입니 가능하다.

+ applicationContext에 정의된 빈이 아니라 ApplicationContext 타입 변수에 붙였는데 어떻게 DI가 가능한 것인가
> 스프링 애플리케이션 컨텍스트는 초기화 활 때 자기 자신도 빈으로 등록한다. 따라서 ApplicationContext 빈이 존재하기 때문에 DI가 가능한 것이다.

이 이유 떄문에 ApplicationContext가 갖고 있는 빈을 DI 받을 수 있다면 getBean()을 쓰지 않고 UserDao를 직접 DI를 받을 수가 있다.

대신 같은 타입의 빈이 두 개 이상 설정되어 있다면 문제가 될 수 있다.

``` java
public class UserDaoTest {  
@Autowired  
UserDao dao;
```

추가로 컨테이너 없는 DI 테스트가 있는데 context 없이 직접 주입해서 사용하는 방식이다 이건 앞에서 해왔던 방식과 비슷하기 때문에 넘어가도록 하겠다.

+ 그렇다면 이 세 가지 방법중 어떤 것을 선택해야 하는가?
> 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려해야한다.
   이 방법이 테스트 수행 속도가 가장 빠르고 간결하다.
> 때로는 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야하는 경우가 있는데 이 때는 스프링 설정을 이용한 DI 방식의 테스트를 사용하자


### 5. 학습 테스트로 배우는 스프링
<hr>

개발자는 때로는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이를 <b>학습 테스트</b>라고 한다.

학습 테스트의 목적은 사용할 API나 프레임워크의 기능을 보면서 사용 방법을 익히는 것이다.

따라서 기능의 검증보다는 이해와 사용 방법을 검증하는 것이다.

+ 장점
> 1. 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수가 있다.
> 2. 학습 테스트 코드를 개발 중에 참고할 수 있다.
> 3. 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
> 4. 테스트 작성에 대한 좋은 훈련이 된다.


## 3. 템플릿
### 3.1 다시 보는 초난감 DAO
<hr>

* UserDao 코드에는 예외상황에 대한 처리에 대한 문제점이 남아있다.
##### 1. 예외처리 기능을 갖춘 DAO
	JDBC 코드에는 반드시 지켜야할 원칙이 있다.
	그것은 바로 예외처리이다. 
	정상적인 JDBC 코드의 흐름을 따르지 않고 예외가 발생했을 경우 사용한 리소스를 반드시 반환하도록 
	만들어야 하기 때문이다.
	일반적으로 서버는 제한된 개수의 DB 커넥션을 만들어 관리한다.
	DB 풀은 매번 커넥션을 close()를 해서 돌려줘야지만 재사용할 수 있다.
	어느 순간에 커넥션 풀의 여유가 없어진다면 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.
##### 2. 변하는 것과 변하지 않는 것
	try/catch/finally는 모든 메소드마다 반복된다.
	실수를 하지 않고 완벽하게 작성했더라도 잠재적 위험성이 있다.
	이런 코드를 효과적으로 다룰 수 있는 방법은 변하지 않는 곳과 변하는 코드를 분리해내는 것이다.
	분리만 해내는 것은 재사용성이 떨어지기 때문에 의미가 없다.
	이럴 때 하는 것은 디자인 패턴을 적용하는 것이다.
	템플릿 메소드 패턴 / 전략 패턴을 적용한다.
	변하지 않는 코드에 사용하는 메서드를 추상 메서드 또는 인터페이스로 분리한다.
	클라이언트 즉 최상단 클래스에서 인터페이스 구현 클래스를 구현 및 인스턴스 생성 후 
##### 3. JDBC 전략 패턴의 최적화
	지금까지의 코드 개선 작업 덕에 DAO 코드가 한결 간결해졌다.
	DAO 코드 양을 많게는 70~80까지 줄일 수 있다.
	지금까지의 작업의 문제점은 결국 새로운 기능을 작업하려면 매
	번 전략패턴에서 구현한 인터페이스의 구현 클래스를 만들어야 
	한다는 것이다.
	또한 구현부에서 필요한 부가적인 정보가 있을 경우 구현 클래스에서 생성자와 인스턴스 변수를 번거롭게 만들어야 한다는 것이다.
	클래스가 많아지는 것은 하나의 해결방법이 있 다.
	중첩 클래스 또는 익명 클래스 를 만드는 것이다.
	중첩/익명 클래스를 사용하면 자신이 정의된 메소드의 로컬 변수에도 직접 접근할 수 있기 때문에 번거롭게 생성자를 통해 오브젝트를 전달해줄 필요가 없다.


#### 5. 템플릿 콜백의 동작원리
* 지금까지의 코드는 일종의 전략 패턴이 적용된 것이라고 볼 수 있다
* 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다
* 이런 방식을 템플릿/콜백 패턴이라고 부른다.
* 전략 패턴의 컨텍스트를 템플릿이라 부르고 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라 부른다.
##### 2. 콜백의 재활용
	템플릿 콜백 방식은 많은 장범이 있다 기존에 코드를 만들었을 떄 발생하던 문제점을 제거할 수 있다. 또한 메소드는 간절해지고 최소한의 로직만 갖고 있게 된다.
	하지만 매번 메소드에서 익명 클래스를 사용하기 떄문에 읽기가 조금 불편하다. 
	익명 메소드를 분리하여 바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하게 만들었다. 파라미터만 final로 선언해서 콜백 안에서만 직접 사용할 수 있게 하는 것만 주의한다.


## 4. 예외 
### 4-1. 사라진 SQL Exception
#### 1. 초난감 예외처리
	예외가 발생했을 때 아무것도 하지 않고 넘어가 버리는 것은 위험한 일이다.
	프로그램 실행 중에 오류가 있어서 예외가 발생했는데 무시하고 계속 진행하기 때문이다.
	예외를 처리할 때 반드시 지켜야 할 원칙은 모든 예외는 복구되던지 아니면 통보되어야 한다는 것이다.
#### 2. 예외의 종류와 특징
	자바에서 예외는 언체크 예외와 체크 예외가 있다.
	언체크 예외는 RuntimeException과 상속한 클래스들을 의미한다.
	체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 작성해야 한다.
	그렇지 않을 경우 throws를 정의해서 메서드 밖으로 넘겨야한다.
#### 3. 예외처리 방법
	첫번째 예외처리 방법은 문제를 해결해서 정상 상태로 돌려놓는 것이다.
	예외로 인해 기본 작업이 불가능 하다면 다른 작업 흐름으로 유도하는 것이다.
	그냥 예외 메세지를 사용자에게 던지는 것은 복구라고 볼 수 없다.
	
	두번째 방법은 자신을 호출한 곳으로 던져버리는 것이다.
	throws 문으로 예외를 던지거나 catch로 예외를 잡은 후 다시 예외를 던지는 것이다.
	코드에서 발생하는 예외를 던져버리는 건 무책임할 회피일 수도 있다. 
	예외를 회피하는 것은 의도가 분명해야 한다.
	
	마지막으로 예외 전환은 예외를 복구할 수 없기 때문에 예외를 메서드 밖으로 던지는데 그냥 넘기는게 아니라 적절하게 전환해서 던지는 것이다.
	예를 들어 사용자가 중복일 때 에러가 발생하면 SQLException이 아니라 DuplicateUserIdException 같은 예외로 바꿔서 던지는 것이다.
	보통 전환하는 예외에 원래 예외를 담아서 중첩 예외로 만드는 것이 좋다.
	또는 체크 예외를 언체크 예외로 포장하는 방법이 있는데 이는 런타임 예외로 전달하면 시스템 익셉션으로 인식하고 트렌젝션을 자동으로 롤백해주는 역할을 한다.

#### 4. 예외처리 전략
	예외가 발생하는 코드를 깔끔하게 정리하는 데는 신경 써야 할 사항이 많다.
	자바가 처음 만들어졌을 당시에는 통제 불가능한 예외라 할지라도 작업이 중단되지 않게 해주고 상황을 복구해야 했다.
	하지만 서버 환경은 다르다 예외가 발생했을 때 작업을 중지하고 사용자와 커뮤니케이션을 하면서 복구할 방법이 없다.
	차라리 예외를 차단하거나 개발자에게 통보해주는 편이 낫다.
	자바 환경이 서버로 이동하면서 체크 예외의 가치는 떨어지고 있다. 그래서 대응이 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는게 낫다.
	이전에는 복구할 가능성이 조금이라도 있다면 체크 예외로 만들었으나 요즘은 항상 복구할 수 있는 예외가 아니라면 언체크 예외로 만드는 경향이 있다.
	런타임 예외는 예외처리를 강제하지 않으므로 예외상황을 충분히 고려해서 사용해야 한다. 런타임 예외를 사용하는 경우에는 API 문서나 레퍼런스 문서를 통해 예외의 종류, 원인, 활용 방법을 설명해두어야 한다.
	
	런타임 예외 중심 전략은 낙관적인 처리 기법이라고 할 수 있다.
	런타임 예외라도 잡아서 복구 및 대응해줄 수 있으니 문제가 없다라고 보는 낙관적인 태도를 기반으로 한다.
	반면에 외부의 원인이 아닌 로직에 의해 의도적으로 발생시키고 조취를 취하게 하는 예외가 있다. 이를 일반적으로 애플리케이션 예외라고 한다.
	애플리케이션은 두 가지의 처리 방법이 있다
	첫 번째는 특정 값을 리턴하는 것이다.
	허나 사람마다 예외를 0으로 리턴하는 사람과, -999로 리턴하는 사람이 있다.
	상수로 정의해둔 코드를 사용하지 않는다면 위험이 있다.
	
	두 번째 방법은 비즈니스 적인 의미를 띈 예외를 던지도록 하는 것이다.
	예를 들어 잔고 부족일 경우 InsufficientBalanceException을 던진다.
	예외를 처리하는 catch 블록을 호출 직후에 둘 필요는 없다.
	예외가 발생할 수 있는 코드를 try 블록 안에 두고 예외 상황에 대한 처리는 catch 블록에 둘 수 있기 때문에 코드를 이해하기에도 편하다.

#### 5. SQLException은 어떻게 됐나?
	먼저 생각해볼 사항은 복구가 가능하냐는 것이다.
	이 예외는 99% 코드 레벨에서는 복구가 불가능하다.
	문법이 틀렸거나 서버가 다운됐거나 커넥션풀이 꽉찬 등의 경우다.
	시스템 예외라는 것은 개발자에게 전달하는 방법밖에는 없다.
	스프링의 JdbcTemplate는 이 예외처리 전략을 따른다.
	모든 SQLException을 DataAccessException(런타임 예외)로 포장해서 던져준다.
	따라서 JdbcTemplate를 사용하는 메서드에서는 꼭 필요한 경우에만 런타임 예외를 처리하면 된다.
	그 밖에도 스프링의 API 메서드의 정의되어 있는 대부분의 예외는 런타임 예외이다.

### 4-2. 예외 전환
* 예외를 다른 것으로 바꿔서 던지는 에외전환은 런타임 예외로 포장하는 것과 추상화된 에외로 바꿔서 던져주는 것 두 가지가 있다
#### 1. JDBC의 한계
	JDBC는 자바를 이용해 DB에 접근하는 방법을 API로 정의해놓고 각 DB가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다.
	이에 따라 JDBC에만 익숙해지면 DB 종류에 상관없이 프로그램 개발이 가능했다.
	하지만 데이터 엑세스 코드를 작성하는 일은 쉽지 않다
	첫째 문제는 코드에서 사용하는 SQL이다 
	다양한 목적으로 최적화 기법을 SQL에 적용등을 거쳐 비표준 SQL 문장이 만들어진다. 이는 특정 DB에 종속적이게 되고 만다.
	이 문제의 해결책은 표준 SQL만 사용하거나 DB별로 별도의 DAO를 만드는 것이다. 
	표준만 사용하기에는 페이징부터 문제가 된다 결국 DAO를 DB 별로 만들거나 SQL을 외부에서 독립시켜서 쓸 수 있게 하는 것이다.
	
	두번째 문제는 SQLException이다.
	DB마다 에러의 종류와 원인도 제각각이다. 그래서 JDBC는 데이터 처리 중에 발생하는 예외를 그냥 SQLException 하나에 박아버린다. 그런데 SQLException 안에 담긴 에러 코드는 DB 별로 모두 다르다 그래서 SQLException은 예외가 발생했을 때의 DB 상태를 담은 SQL 상태 정보를 부가적으로 제공한다.
	이 상태 정보는 DB마다 달라지는 에러 코드를 대신할 수 있도록 XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르도록 되어 있다. 그런데 문제는 상태 코드를 정확하게 만들어주지 않는다는 점이다. 결국 SQLException만으로 DB에 독립적인 코드를 작성하는 건 불가능에 가깝다.
#### 2. DB 에러 코드 매핑을 통한 전환
	해결방법은 DB별 에러 코드를 참고해서 예외의 원인을 해석해주는 것이다.
	키 값이 중복되는 것은 MySQL 1062 DB2라면 -803이라는 에러 코드를 받게 된다.
	이 에러 코드 값을 확인할 수 있다면 의미가 분명히 드러나는 예외로 전환할 수 있다.
	스프링은 DataAcessException이라는 런타임 예외를 정의하고 있을 뿐 아니라 서브 클래스로 세분화된 예외 클래스들을 정의하고 있다.
	문제는 에러코드가 제각각이라는 건데 코드에서 db별로 종류를 확인하는 건 부담이 너무 크다. 대신 스프링은 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 테이블을 만들어놓고 이를 이용한다.
	JdbcTemplate은 SQLException을 런타임 예외로 포장하는 것만이 아니라 에러 코드를 서브 클래스 중 하나로 매핑해준다.
#### 3. DAO 인터페이스와 DataAccessException 계층 구조
	DAO는 엑세스 로직을 담은 코드를 다른 코드에서 분리해놓기 위해서 사용한다.
	또한 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용하려고만드는 것이기도 하다.
	DAO는 클라이언트에게 감출 수 있지만 예외 정보가 문제가 될 수 있다. 만약 JDCB가 아닌 다른 데이터 엑세스 기술을 사용한다면 예외가 각각 다르기 때문에 기존에 예외를 던지는 인터페이스 메소드는 사용할 수 없다. 가장 간단한 방법은 모든 예외를 받아주는 Exception으로 선언하는 것이지만 무책임하다.


## 5. 서비스 추상화
	5장에서는 지금까지 만든 DAO에 트랜젝션을 적용해보면서 스프링이 어떻게 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴볼것이다.
### 5-1. 사용자 레벨 관리 기능 추가
	지금까지의 기능은 CRUD라 불리는 기초적인 기능만 가능하다.
	여기에 비즈니스 로직을 추가해보자

> 사용자의 레벨은 Basic, Silver, Gold 중 하나다.
> 사용자가 처음 가입하면 Basic 레벨이 된다.
> 가입 후 50회 이상 로그인을 하면 SILVER 레벨이 된다.
> SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
> 사용자 레벨의 변경 작업은 일정한 주기를 가지고 진행된다.

#### 1. 필드 추가
	테이블에 레벨을 저장할 필드를 추가한다. 
	상수 int로 할 수 있지만 이 방법을 쓰는 것은 지양하는 것이 좋다.
	만약 다른 종류의 데이터를 넣는 실수를 하더라도 실수를 체크해주지 못한다.
	따라서 직접적은 숫자 타입을 사용하는 것보다는 enum을 이용하는게 안전하다.
	enum은 내부적으로는 int 타입을 갖고 있지만 겉은 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.

#### 2. 수정 기능 추가
	사용자 정보는 여러 번 수정될 수 있다.
	수정되는 필드에 종류에 따라서 여러개의 수정용 메서드를 만들어야 할 때가 있다.
	하지만 아직은 사용자 정보가 단순하고 자주 변경되지 않기 때문에 간단히 접근한다.
	수정할 정보가 담긴 오브젝트를 전달하면 id를 참고해서 필드 정보를 update문을 이용해
	모두 변경해주는 메서드를 구현한다.
	
	JDBC에서 리소스 반환과 같은 작업을 제외하고 가장 많이 일어나는 것은 sql 문장이다.
	
	이 문제를 해결할 방법은 첫번째로는 update가 돌려주는 리턴 값을 확인하는 것이다.
	테이블의 내용에 영향을 주는 sql을 실행하면 영향을 받은 로우의 개수를 돌려준다 
	
	두번째 방법은 테스트를 테스트를 보강하는 것이다.
	수정된 사용자와 수정하지 않은 사용자를 비교한다.
	
	테스트는 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다.
	경계값을 이용해 가능한 모든 경우를 체크해야한다.
	
	사용자는 기본적으로 basic 레벨이어야 한다.
	dao는 오브젝트를 db에 넣고 읽는 방법에만 관심을 가져야지 비즈니스적인 의미를 지닌 정보를 설정하는 것은 바람직하지 않다.
	User 클래스에서 초기화해버리는 것은 나쁘지 않은 생각이긴 하지만 처음 가입할 때가 아니면 무의미한 정보이기 때문에 문제가 있어보인다.
	그렇다면 사용자 관리에 대한 비즈니스 로직을 담고 있는 UserService에 로직을 할당한다.
	
	작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.
	1. 코드에 중복된 부분은 없는가?
	2. 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
	3. 코드가 자신이 있어야 할 자리에 있는가?
	4. 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
	
### 5-2. 트랜잭션 서비스 추상화
	만약 테스트를 하다가 중간에 외부 인터럽트가 발생하면 어떻게 될까
#### 1. 모 아니면 도
	지금까지 만든 사용자 레벨 업그레이드 코드는 어떻게 될까
	테스트를 만들어서 확인해보야야 한다.
	하지만 업그레이드 작업을 수행하다가 중간에 외부 인터럽트를 만드는 것은 불가능하다.
	테스트의 기본은 자동화이다. 사람이 간섭해서는 안 된다.

	어떻게 예외를 강제로 만들 수 있을까?
	그것은 애플리케이션 코드를 수정해 예외를 던지는 것이다.
	UserService 코드를 수정하는 것이 좋다.
	그렇다면 테스트용 UserService 코드는 어떻게 만드는 것이 좋을까
	기존 클래스를 복사해서 만들기엔 중복 및 번거로워 보인다. 
	UserService 코드를 상속해서 메서드를 오버라이딩 하는것이 나은 것 같다.

	테스트 코드를 실행하면 이제 예외가 정확히 나올 것이다.
	하지만 돌려보면 테스트가 실패했다고 뜬다ㅏ.
	이유는 네 번째 사용자 처리 중에 예외가 발생했지만 그대로 유지되고 있는 것이다.
	이것은 바로 트랜젝션 문제이다.
	모든 사용자의 레벨을 업그레이드 하는 작업인 upgradeLevels() 메서드가 하나의 트랜젝션에서 동작하지 않았기 때문이다.
	모든 사용자에 대한 레벨 작업은 모두 성공되거나 모두 실패되어야 한다.
	따라서 중간에 예외가 밠갱해서 작업을 완료할 수 없다면 초기 상태로 돌려놔야한다. 이것이 트랜젝션이다.
	ㅇㄹ
	DB는 그 자체로 완벽한 트랜젝션을 지원한다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜젝션을 보장해준다고 믿을 수 있다.
	하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜젝션으로 취급해야 하는 경우가 있다.
	은행 시스템의 계좌이체 작업은 반드시 하나의 트랜잭션으로 묶여서 일어나야 한다.
	이체를 할 때에는 이체금액만큼 줄어들고 입금 계좌에는 이체 금액만큼 증가되어야 한다.
	이 때 이체 프로그램은 DB에 두 번 요청을 보낸다.
	문제는 첫 번째를 성공적으로 실행했지만 두 번째 SQL이 성공하기 전에 장애가 생겨서 중단되는 경우이다.
	이 두 개의 작업이 하나의 트랜잭션이 되려면 앞엣허 처리한 작업도 취소되어야 한다.
	이 작업을 트랜잭션 롤백이라고 한다.
	반대로 모두 수행되면 트랜젝션 커밋이라고 한다.

	 모든 트랜젝션은 시작하는 지점과 끝 지점이 있다.
	 시작하는 방법은 한 가지이지만 끝나는 지점은 롤백을 하거나 커밋을 하거나에 해당하는 두 가지가 있다.
	 이를 트랜젝션 경계라고 부르는데 정확한 트랜잭션 경계를 설정하는 것은 매우 중요한 작업이다.
	 JDBC의 트랜잭션은 하나의 커넥션을 가져와 사용하다가 닫는 사이에 이루어진다.
	 기본 설정은 auto 커밋으로 되어 있다 
	 이 기능을 끄면 새로운 트랜잭션이 시작되게 만들 수 있다.
	 한 번 시작되면 commit() 또는 rollback()이 호출될 때까ㅓ지 작업이 하나의 트랜잭션으로 묶인다.

	그렇다면 이제 왜 우리가 한 테스트 코드에서는 적용되지 않았는지 생각해보자
	간단하다 지금 코드에서는 어디에도 시작하고 커밋하고 롤백하는지 설정하는 코드가 존재하지 않는다.
	JDBC 템플릿은 하나의 메서드 안에서 커넥션이 만들어지고 닫히는 일까지 일어난다.
	일반적으로 트랜젝션은 커넥션보다 범위가 짧다. 따라서 메서드가 호출 될 때마다 트랜잭션이 만들어지고 빠져나오기 전에 종료된다. 따라서 예외가 발생해서 롤백이 되더라도 이미 이전 작업은 db에 반영되었기 때문에 남아있는 것이다.

	그렇다면 여러 번 DB에 업데이트를 해야 하는 작업을 할 때 하나로 묶으러면 어떻게 해야하나
	어떤 일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 커넥션도 하나만 사용되어야 한다.
	트랜잭션은 커넥션 안에서 만들어지기 때문이다.

	이 문제를 해결하기 위해 dao 메서드 안으로 메서드의 내용을 옮기는 방법을 생각할 수 있다.
	하지만 이 방식은 비즈니스 로직과 데이터 로직을 묶어버리는 한심한 결과를 초래한다.
	UserService와 UserDao를 둔 채로 트랜잭션을 적용하려면 결국 트랜잭션을 UserService로 가져와야한다.
	upgradeLevels의 시작과 메서드를 빠져나올 때 트랜잭션이 종료되어야 하기 때문이다.

	이런 방식으로 UserService와 UserDao를 수정하면 문제를 해결할 수는 있겠지만 여러가지 문제가 발샏ㅇ한다.
	1. JdbcTemplate를 더 이상 이용할 수는 없다.
		1. try catch finally 블록은 Service 내에 존재하고 JDBC의 작업 코드의 문제점ㄷ을 가질 수 밖에 없다.
		2. DAO 메서드에 Connection 파라미터가 추가되어야 한다.
			1. 메서드 어딘가에서 Connection을 필요로 한다면 그 사이에 존재하는 모든 메서드에 Connection이 모두 전달되어야 한다. UserService는 빈으로 싱글톤으로 되어 있기 때문에 인스턴스 변수로 커넥셙을 저장할 수도 없다.
		3. 더 이상 데이터 엑세스 기술에 독립적일 수 없다.
			1. JPA는 EntityManage를 사용하는데 결국 UserDao는 DAO 마다 코드가 수정됭너야 할것이다.
	스프링은 이 딜레마를 해결할 수 있는 멋진 방법을 제공해준다.

	먼저 커넥션을 파라미터로 직접 전달하는 문제를 해결해보자
	upgradeLevels() 메서드가 트랜잭션 경계설정을 해야 한다는 사실은 피할 수 없다.
	따라서 그 안에서 커넥션을 생성하고 트랜잭션의 시작과 종료를 관리하게 한다.
	대신 여기서 생성된 커넥션을 dao를 호출할 때 사용하게 하는건 피하고 싶다.
	이를 위해 스프링이 제안하는 방법은 독립적인 트랜잭션 동기화이다.
	트랜젝션 동기화란 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 dao 메서드에서는 저장된 connection을 가져다가 사용하게 하는 것이다.
	정확히는 dao가 사용하는 jdbctemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다.
	트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 커넥션을 저장하고 관리하기 때문에 충돌이 날 염려는 없다.
	

	jdbcTemplate은 jdbc 작업의 템플릿 메소드를 호출하면 직접 커넥션을 생성하고 종료하는 일을 모두 담당한다.
	특별한 준비 없이 직접 dao를 사용했을 때도 제대로 동작하는 것을 보면 스스로 커넥션을 생성해서 사용한다는 것을 알 수 있다.
	jdbctemplate은 영리하다 미리 생성되어서 트랜잭션 동기화 저장소에 커넥션 및 트랜잭션이 없는 경우에는 직접 커넥션을 만들고 트랜잭션을 시작하낟.
	반면에 upgradeLevels() 메소드에서처럼 직접 커넥션을 만드는 대신 저장소에 들어있는 db 커넥션을 가져와서 사용한다.
	따라서 트랜잭션을 이용할 때 굳이 필요 없다면 바로 호출해서 사용하면 되고 관리할 필요가 있다면 미리 커넥션을 생성 후 동기화를 해주고 사용하면 된다.

#### 2. 트랜잭션 서비스 추상화
	지금까지 만들어온 UserService와 UserDao, UserDaoJdbc는 트랜잭션을 적용했으면서도, 책임과 성격에 따라 데이터 엑세스 부분과 비즈니스 로직을 잘 분리한 코드이다.

	그런데 새로운 문제가 발생했다.
	만약 하나의 트랜잭션 안에서 여러 개의 DB에 데이터를 넣는 작업을 할 필요가 발생했다.
	한 개 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는 것은 로컬 트랜잭션으로는 불가능하다.
	로컬 트랜잭션은 DB 커넥션에 종속되기 때문이다.
	따라서 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 글로벌 트랜잭션 방식을 사용해야 한다.
	글로벌 트랜잭션을 적용해야 여러 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다.
	자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원하는 JTA를 제공하고 있다.

	userDao가 DAO 패턴을 사용해 두현 데이터 엑세스 기술을 유연하게 바꿨지만 UserService에서 트랜잭션 경계 설정을 하면서 특정 데이터 엑세스 기술에 종속되는 구조가 되고 말았다.
	userService의 코드가 특정 트랜잭션에 의존적이지 않고 독립적으로 만들려면 어떻게 해야할까?
	다양한 트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는다.
	DB에서 제공하는 DB 클라이언트 라이브러리와 API는 서로 호환이 안 되지만 모두 SQL을 사용한다는 공통점이 있다. 이 공통점을 뽑아내 추상화를 한 것이 JDBC이다.
	그렇다면 트랜잭션 처리 코드에도 추상화를 도입할 수 있을까?
	JDBC, JTA, 하이버네이트, JPA, JDO 심지어는 JMS도 트랜잭션 개념을 갖고 있으니 공통점이 있을 것이다. 긔리고 애플리케이션 코드에서는 트랜잭션 추상 계층이 제공하는 API를 이용해 트랜잭션을 이용하게 만들어준다면 특정 기술에 종속되지 않는 트랜잭션 코드를 만들 수 있을것이다.

### 5-3. 서비스 추상화와 단일 책임 원칙
	스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있게 됐다. 
	기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
	dao와 service는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고, 
	서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하도록 만든 것이다.
	트랜잭션의 추상화는 이와는 좀 다르다 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.
	이런 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 단일
	책임 원칙으로 설명할 수 있다. 단일 책임 원칙은 하나의 모듈은 하나의 책임만 가져야 한다는 것이다.
	이전에 JDBC Connection을 직접 사용하는 트랜잭션 코드가 들어있던 UserService는 어떻게 사용자 레벨을 관리할 것인가와, 어떻게 트랜잭션을 관리할 것인가에 해당하는 두 가지의 책임을 가지고 있었다. 이 말은 코드가 수정되는 이유가 두 가지라는 것이다. 결국 단일 책임 원칙을 지키지 못하는 코드다.
	하지만 이렇게 추상화를 도입하고, DI를 통해 외부에서 제어하도록 만들고 나서는 UserService가 바뀔 이유는 한 가지 뿐이다. 사용자 관리 로직이 바뀌지 않는 이상 코드에는 손댈 이유가 없다.

	단일 책임 원칙을 잘 지키고 있다면 수정 대상이 명확하다는 장점이 있다.
	기술이 바뀌면 기술 계층과의 연동을 담당하는 추상화 계층의 설정만 바꿔주면 된다.
	테이블의 이름이 바뀌었다면 데이터 엑세스 로직을 담고 있는 UserDao를 변경하면 된다.
	많은 코드를 수정하는 과정에서는 그 만큼 실수할 가능성이 크다.
	개발 중이 아니라 운영 중인 코드에 이런 수정이 필요하다면 엄청난 부담을 안고 작업을 진행해야 한다.
	그래서 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 추상화 기법을 도입하고, 로직과 기술/환경을 분리하는 등의 작업은 엔터프라이즈어플리케이션에는 반드시 필요하다. 이를 제공하는 것이 스프링의 DI이다.
	만약 DI가 없었다면 직접 new로 구체적인 의존 클래스를 설정하므로 비즈니스 로직을 담은 코드의 수정이 발생한다. 결국 의존관계 설정을 DI를 이용하여 스프링에 맡긴 덕분에 트랜잭션에서 자유로운 service를 가지게 된 것이다.

	일일이 설계 원칙이니 디자인 패턴이니 우너리를 따져가면서 만들기는 슂비 않다. 그 개념을 익히는 것도 부담이다. 좋은 코드를 설계하고 만들려면 꾸준한 노력이 필요하다. 코드에 만족하지 않고 개선하려는 자세도 필요하다.

	지금까지 코드를 개선하고 발전시켜온 과정을 보면 DI가 빠진 적이 없었다.
	이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심 원리이며, 가장 중요한 도구이다. 스프링을 DI 프레임워크라고 부르는 이유는 스프링이 DI에 담긴 원칙과 이를 응용하는 모델을 적극적으로 활용하고 있기 때문이다.
## 6. AOP
### 6-1. 트랜잭션 코드의 분리
	트랜잭션 경계설정 코드의 분리와 DI를 통한 연결은 지금까지 해왔던 작업 중에서 가장 복잡한 작업이었다 이로 인해 얻을 수 있는 장점은 무엇인가?

	첫째 비즈니스 로직을 담당하는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
	트랜잭션은 DI를 이용해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 된다. 따라서 언제든지 트랜잭션을 도입할 수 있다.
	두번째 장점은 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다는 것이다.
### 6-2. 고립된 단위 테스트
	가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트 하는 것이다.
	작은 단위의 테스트가 좋은 이유는 실패했을 때 원인을 찾기 쉽기 때문이다.
	클래스 하나가 동작하도록 테스트를 만드는 것 클래스 수십 개가 얽히고 설혀서 동작하도록 만드는 것 어떤 것이 논리적인 오류를 찾기 쉬울지는 분명하다.
	따라서 테스트는 작은 단위로 하면 좋다 하지만 작은 단위로 테스트하고 싶어도 그러지 못하는 경우가 많다.

	UserService는 간단한 기능만을 갖고 있다
	그럼에도 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다.
	따라서 UserService를 테스트 하려면 사실은 그 안에 존재하는 의존 오브젝트와 환경 서비스 서버 심지어 네트워크까지 함께 테스트하게 된다.
	그 중 어떤 것이라도 바르게 셋업되어 있지 않거나 문제가 있다면 테스트가 실패해버린다. 이런 경유의 테스트는 준비하기 힘들고 환경이 조금이라도 달라지면 테스트 결과를 내지 못할 수도 있으며 실행하는 빈도가 점차 줄어들 것이 분명하다.

	그래서 테스트의 대상이 외부 요인의 영향을 받지 않도록 고립시킬 필요가 있다. 테스트를 분리해서 고립시키는 방법은 테스트를 위한 대역을 이용하는 것이다.
	mailsender에는 이미 dummymailsender라는 테스트 스텁을 적용했다.
	테스트 대역이 검증에도 참여할 수 있도록 목 오브젝트도 사용해봤다.

	고립된 테스트가 가능하도록 UserService를 재구성해보면
	트랜잭션을 제거한 UserServiceImpl과
	트랜잭션을 분리한 UserServiceTx로 구성할 수 있다.
	UserServiceImpl은 실제 비즈니스 로직 자체만 테스트를 진행하고
	UserServiceTx는 DB등 외부 요인도 같이 테스트를 진행한다.

	mock을 이용한 테스트의 장점은 수행시간의 차이이다.
	보통 mock을 사용한 테스트와 mock을 사용하지 않은 테스트의 시간 차는 500배 가량 난다고 한다
	현 프로젝트는 복잡하지 않은 비즈니스 로직을 가지고 있지만
	사이즈가 큰 테스트라면 테스트를 수행하는 시간은 점점 길어질 것이다.

	고립된 테스트를 만들려면 목 오브젝트 작성과 같은 수고가 필요하지만 그 보상은 충분히 기대할 만 하다.

	통합 테스트란 두 개 이상의 단위가 결합해서 테스트가 수행되는 것이다.
	스프링 테스트 컨텍스트 프레임워크를 이용해서 DI된 오브젝트를 테스트하는 것도 통합 테스트이다.

	가이드라인이다.
	1. 항상 단위 테스트를 먼저 고려한다.
	2. 외부와의 의존관계를 모두 차단하고 테스트 대역을 이용하도록 테스트를 만든다.
	3. 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
	4. DAO는 직접 DB를 통해 수행하기 때문에 DB까지 연동하는 테스트로 만드는 것이 효과적이다.
	5. DAO 테스트는 통합 테스트로 분류된다. 하지만 코드에서 보자면 하나의 기능 단위를 테스트하는 것이기도 하다.
	6. 여러 개의 단위가 의존 관계를 갖고 동작한다면 통합 테스트는 필요하다.
	7. 단위 테스트로 만들기가 너무 복잡하다고 판단되는 코드는 통합 테스트를 고려해보자
	8. 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트이다. 
	여기까지의 과정은 모두 개잘자 테스트이다. 전문 테스터나 고객에 의해 진행되는 테스트는 다른 관점에서 생각해야 한다.
	테스트는 코드가 작성되고 가능한 한 빨리 작성하도록 해야한다.
	코드를 작성하면서 테스트는 어떻게 만들 수 있을까 생각해 보는 것은 좋은 습관이다.
	테스트 하기 편하게 만들어진 코드는 깔끔하고 좋은 코드가 될 가능성이 높다.
	스프링이 지지하고 권장하는 깔끔하고 유연한 코드는 그만큼 만들기 쉬워지고 품질과 리펙토링에 대한 용기를 줄것이다.

	단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.
	대부분 의존 오브젝트를 이용하기 때문이다. 
	단위테스트를 만드는 것은 복잡하다 기능마다 인터페이스를 구현해줘야하기 때문이다. 
	다행히도 이런 목 오브젝트를 편리하게 작성하도록 도와주는 오브젝트 지원 프레임워크가 있다.
	그 중에서도 Mockito 프레임워크는 사용하기도 직관적이어서 많은 인기를 끌고 있다.
	이 라이브러리의 장점은 목 클래스를 일일이 준비해둘 필요가 없다는 것이다.

	목 오브젝트는 네 단계를 걸쳐서 사용한다.
	1. 인터페이스를 이용해 목 오브젝트를 만든다.
	2. 목 오브젝트가 리턴할 값이 있으면 이를 저장해준다. 메서드가 호출되면 강제로 예외를 던지게 만들 수도 있다.
	3. 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
	4. 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메서드가 호출됐는지 검증한다.

### 6-3. 다이내믹 프록시와 팩토리 빈
	단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전형적인 전략 패턴을 사용하면 된다.
	하지만 전략 패턴은 구현 부분만 분리해냈을 뿐이지 트랜잭션을 적용한다는 코드는 그대로 코드에 남아있다.
	트랜잭션이라는 기능은 비즈니스 로직과는 성격이 다르기 때문에 아예 그 적용 사실 밖으로 분리할 수 있다.
	이 방법을 이용해 UserServiceTx를 만들었고 UserServiceImpl에는 트랜잭션 관련 코드가 하나도 남지 않게 됐다.
	이렇게 분리된 부가기능을 담은 클래스는 중요한 특징이 있다.
	부가기능 외의 나머지 기능은 모두 핵심 기능을 가진 클래스로 위임해줘야 한다는 것이다.
	따라서 부가기능이 핵심기능을 사용하는 구조가 된다는 것이다.
	문제는 클라이언트가 핵심기능을 가진 클래스를 바로 사용해버리면 부가 기능이 적용될 기회가 없다는 것인데, 그래서 부가 기능은 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거치도록 만들어야 한다.
	부가기능 코드에서 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다. 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 대표적인 경우이다.
	이렇게 마치 자신이 실제 대상인 것처럼 위장해서 요청을 받아주는 것을 대리자라고 해서 프록시라고 부른다 실제 요청을 위임받아 처리하는 오브젝트를 타깃 혹은 실체라고 부른다.

	데코레이터 패턴은 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
	다이내믹하게 기능을 부여한다는 것은 코드상에서는 어떤 방법과 순서로 타깃이 연결되어 사용되는지 정해져있지 않다는 것이다.
	데코레이터라고 불리는 이유는 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있다는 것이다. 따라서 프록시의 개수를 제한해두지 않는다.
	예를 들면 자바 IO 패키지에 InputStream과 OutputStream인데 InputStream을 구현한 FileInputStream에 버퍼 읽기 기능을 제공해주는 BufferedInputStream이 데코레이터를 적용한 예이다.
	UserService를 구현한 UserServiceImpl에 트랜잭션 부가기능을 제공해주는 UserServiceTx를 추가한 것도 데코레이터 패턴이라고 볼 수 있다.

	일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다.
	프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고 타깃에 접근하는 방식을 변경해준다.
	타깃 오브젝트가 생성하기 복잡하거나 당장 필요 없으면 필요할 때까지 오브젝트를 생성하지 않는 것이 좋다.
	그런데 타깃 오브젝트에 대한 레퍼런스가 필요할 수 있다. 이럴 때 프록시 패턴을 적용하면 되는 것이다.
	클라이언트에게 타깃에 대한 래퍼런스를 넘겨야 하는데 실제 타깃 오브젝트 대신 프록시를 넘겨주는 것이다. 그리고 프록시의 메서드를 통해 타깃을 사용하려고 시도하면 그 때 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
	원격 오브젝트를 이용하는 경우에 프록시는 편리하며 특별한 상황에서 접근 권한을 제어하기 위해 프록시 패턴을 사용할 수 있다.
	Collections의 unmodifiableCollection()을 통해 만들어지는 오브젝트가 대표적이다.

	프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.
	하지만 프록시를 만드는 것은 번거롭기 때문에 만들지는 않겠다고 생각한다.
	그렇다면 프록시도 일일이 모든 인터페이스를 구현해서 새로 정의하지 않고 편리하게 만들어서 사용할 방법은 없을까
	자바에는 java.lang.reflect 패키지 안에 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다.
	프록시는 두 가지의 기능으로 구현되어 있다. 
	타깃과 같은 메소드를 구현하고 있다가 호출되면 타깃 오브젝트로 위임
	지정된 요청에 대해서는 부가기능 수행하는 코드로 구분할 수 있다
	그렇다면 만들기가 번거로운 이유가 무엇일까
	첫째는 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다
	부가기능이 필요없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
	두번째는 부가기능 코드가 중복될 가능성이 많다.
	이를 해결해줄 수 있는 것이 JDK의 다이내믹 프록시다.

	다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
	리플랙션은 자바 코드 자체를 추상화해서 접근하도록 만든 것이다.
	자바의 모든 클래스는 Class 타입의 오브젝트를 하나씩 갖고 있다.
	클래스를 통해 오브젝트의 값을 수정 등 다양한 것을 할 수 있다.

	Proxy의 newProxyInstance() 메서드를 통해서만 생성이 가능한 다이내믹 프록시 오브젝트는 일반적인 방법으로 스프링 빈으로 등록이 불가능하다.
	대신 팩토리 빈에 getObject() 메서드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 된다.

	데코레이터 패턴이 적용된 프록시를 사용하면 인터페이스를 일일이 만들어 내야 한다는 단점과 코드 중복의 문제가 발생한다고 했다.
	지금까지 살펴본 프록시 팩토리 빈은 이 문제를 해결해준다.
	프록시 팩토리 빈은 프록시 기법을 편리하게 적용할 수 있게 해준다. 하지만 중복 없는 코드와 설정만을 이용해 이 기능을 적용하려고 한다면 한계에 부딪힐 것이다.
	프록시를 통해 부가기능을 제공하는 것은 메서드 단위로 일어난다. 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하는 일은 지금까지의 방법으로는 불가능하다.
	하나의 타깃에 여러가지 부가 기능을 적용하려고 할 때도 문제다

	지금까지 기존 코드의 수정 없이 트랜잭션 부가기능을 추가해줄 수 있는 방법을 살펴봤다.
	스프링은 세련되고 깔끔한 방식으로 이런 문제에 대한 해법을 제공한다.
	스프링은 서비스 추상화를 프록시 기술에서도 동일하게 적용한다.
	스프링은 일관된 방법으로 프록시를 만들 수 있게 도와주는 추상 레이어를 제공한다.

	proxyfactoryBean은 프록시를 생성해서 빈 오브젝트로 등록해주는 팩토리 빈이다.
	기존에 만들었던 빈과 달리 proxtfactorybean은 순수하게 프록시를 생성하는 작업만 담당하고 부가기능은 별도로 빈에 둘 수 있다.
	생성하는 프록시에서 사용할 부가기능은 MethodIntercptor에서 만든다 MethodInterceptor는 타깃 오브젝트에 대한 내용까지 제공받기 때문에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
	따라서 싱글톤 빈으로 등록이 가능하다.

	ProxyFactoryBean은 템플릿/콜백 구조를 응용해서 적용했기 때문에 MethodInterceptor를 싱글톤으로 공유할 수 있다.
	타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 스프링에서는 어드바이스라고 부른다.
	ProxyFactoryBean은 굳이 인터페이스를 알려주지 않아도 자동검출 기능을 사용해 타깃 인터페이스 정보를 알아낸다.

	기존에 InnovationHandler를 직접 구현했을 때는 부가기능 외에도 한 가지 작업이 더 있었다.
	메서드 이름을 가지고 부가기능을 적용 대상 메서드를 선정하는 것이었다.
	MethodInterceptor를 사용하는 방식도 그런가?
	아니다. 트랜잭션 적용 메서드 패턴은 프록시마다 다르기 때문에 여러 프록시가 공유하는 MethodInterceptor에 적용되는 패턴을 넣으면 문제가 된다.

	스프링은 부가기능을 제공하는 오브젝트를 어드바이스라고 부르고 메서드 선정 알고리즘을 담은 오브젝트를 포인트컷이라고 부른다.
	