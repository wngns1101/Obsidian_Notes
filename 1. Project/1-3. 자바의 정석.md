<hr>

## Chapter 1 

1-1. 자바란?
	 OS에 독립적인 프로그래밍 언어이다.	 

1-3. 자바의 특징
	객체지향의 특징인 *상속, 다형성, 추상화, 캡슐화* 가 잘 적용된 객체지향 언어이다.
	GC를 통해 메모리를 자동으로 관리해준다.
	동적로딩을 지원한다.

1-4. JVM
	자바로 작성된 애플리케이션은 JVM에서만 실행되기 때문에 JVM이 반드시 필요하다.
	다른 언어에 비해 JVM을 한 번 더 거치기 때문에 속도가 느리다는 단점을 가지고 있다.

2-1. 개발도구
	javac.exe -> 자바코드를 바이트코드로 컴파일한다.
	java.exe -> 바이트 코드를 해석하고 실행한다.
	javap.exe -> 컴파일된 바이트코드를 소스코드로 변환한다.
	
	JDK
	JRE + bin(javac.exe 등)
	JVM + 클래스 라이브러리

3-1. Hello.java
	자바의 모든 코드는 반드시 클래스 안에 존재해야 한다.
	public static void main(Strring[] args) 선언부는 java.exe에 의해 호출될 수 있도록 약속한 부분이기 때문에 필수이다.
	클래스는 최소한 하나는 main 메서드를 가지고 있어야 한다.
	public 클래스가 있는 경우 파일의 이름과 일치해야 한다.
	public 클래스가 없어도 된다. 대신 둘 이상의 public 클래스는 존재할 수 없다.

3-3. 실행과정
	프로그램의 실행에 필요한 클래스 .class 파일을 로드한다.
	클래스 파일을 검사한다.
	지정된 클래스에서 main 메서드를 호출한다.

3-4. 주석
	주석은 범위 주석 과 한 줄 주석이 있다.
	컴파일러는 주석을 무시하기 때문에 주석이 성능에 영향을 주지 않는다.


## Chapter 2 변수
1-1. 변수
	변수란 값을 저장할 수 있는 메모리 상의 공간을 의미한다.
1-3. 변수의 명명규칙
	대소문자가 구분되며 길이 제한이 없다. (True, true)
	예약어를 사용해서는 안 된다. (true)
	숫자로 시작해서는 안 된다.
	자바 프로그래머들에게 권장되는 규칙
	클래스의 첫 글자는 항상 대문자로 한다.
	여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
	상수의 이름은 모두 대문자로 한다.
2-0. 변수의 타입
	자료형은 기본형과 참조형으로 구분된다.
	기본형 변수는 실제 값을 저장한다.
	참조형 변수는 값이 저장되어 있는 주소를 값으로 갖는다.
	기본형의 종류를 얘기할 때는 자료형이라 하고 참조형의 종류를 얘기할 때는 타입이라고 한다.
2-1. 기본형
	기본형에는 모두 8개의 타입이 있다.
	크게 논리형, 문자형, 실수형으로 구분된다.
	각 타입마다 저장할 수 있는 값의 범위가 다르다.
	1byte = Boolean, byte
	2byte = char, short
	4byte = float, int
	8byte = double, long
	각자 범위에 맞는 타입을 작성하면 되지만 일반적으로 int를 많이 사용한다.
	왜냐하면 int가 cpu가 제일 잘 처리할 수 있는 타입이기 때문이다.
	효율보다 메모리를 우선시한다면 byte, short를 사용해야한다.
	int 타입의 변수는 대락 10자리 수의 값을, 7~9자리의 수를 계산할 때는 long을 잡는게 좋다.
	실수형은 정수형보다 큰 값을 표현할 수 있으나 오차가 발생할 확률이 높다
	정밀도가 클 수록 오차 범위는 줄어드는데 float는 7자리 double은 15자리로 측정된다.
2-2. 상수와 리터럴
	상수는 값을 한 번 저장하면 다른 값으로 변경할 수 없다. final 키워드를 붙여주기만 하면 된다.
	상수는 반드시 선언과 동시에 초기화 해주어야 한다.
	상수의 이름은 모두 대문자로 하는 것이 관례이다.
	상수는 한 번 저장하면 변경할 수 없는 저장공간으로 정의되기 때문에 리터럴이라고 불린다. final이 없으면 변수고 final이 붙어있으면 상수라고 불린다. 저장되어 있는 모든 값은 리터럴로 불린다.
	변수에 타입이 있는 것처럼 리터럴에도 타입이 있다. Long은 L float는 f, double 타입에는 d를 붙이도록 하자
	보다 큰 타입에 낮은 리터럴 타입은 오류가 발생하지는 않지만 낮은 타입에 큰 리터럴 타입은 오류가 발생한다.
	문자형에 경우에는 char는 ‘’ 문자열은 “” 타입을 사용해야 한다.
	String 클래스는 클래스이기 때문에 new로 생성해야 하지만 예외로 new로 생성하지 않도록 한다.
2-3. 형식화된 출력
	보통 화면에 출력할 때는 println()을 쓴다. 하지만 다른형식으로 출력하고 싶을 때가 있다. 이럴 때는 printf()를 사용한다.
	printf()는 지시자를 통해 변수의 값을 변환해서 출력하는 기능이 있다.
	출력 값이 두 개라면 지시자도 두 개를 사용해야 한다.
	%d는 10진수
	%o는 8진수
	%x는 16진수
	%f는 부동 소수점
	%o는 지수 표현식
	%c는 문자
	%s는 문자열로 출력한다.
2-4. 화면에서 입력받기 - Scanner
	자바애서 입력받는 방법은 여러가지가 있으나 간단한 건 Scanner가 있다.
	Scanner 클래스를 사용하려면 import java.util.을 추가해야 한다.
	그 다음엔 Scanner 객체를 생성해주어야 한다.
	Scanner scanner = new Scanner(System.in)
	입력 받을 때는 보통 nextLine()을 많이 쓴다. 왜냐하면 nextInt()와 같은 것들은 연속적으로 값을 입력받아서 사용하기엔 까다롭다.
	따라서 next line()을 사용하여 줄 단위로 입력받고 형변환을 하는게 낫다.
3-0. 진법
	우리가 일상생활에서 사용하는 것은 주로 10진법이다.
	컴퓨터는 2진법이 적합하다
	n의 보수는 더했을 때 n이 되는 수를 말한다. 7의 10의 보수는 3이다.
	2진 표현을 구하는 방법은 1의 보수로 변환한 후 1을 더해주면 된다.
4-0 기본형
4-1. 논리형
	논리형은 Boolean 타입 한 가지 밖에 없다(true, false)
	기본값은 false이다
	원래는 true, false만 갖고 있기 때문에 1bit로 표현이 가능하지만 자바에서는 데이터를 다루는 최소 단위가 byte이기 때문에 1byte의 크기이다.
4-2. 문자형
	문자형 역시 char 한 가지 자료형밖에 없다.
	문자를 저장하기 위한 변수를 선언할 때 사용되며 한 가지의 문자만 사용할 수 있다.
	문자형은 문자가 저장되는 것 같지만 사실은 유니코드가 저장된다.
	그래서 문자 대신 유니코드를 저장하는 것이 가능하다.
	만약 유니코드를 알고 싶으면 (int)형으로 변환하여 확인할 수 있다.
	영문자 이외에 특수문자를 저장하려면 특별한 방법을 사용해야한다.
	tab > \\t
	Backspace > \\b
	new line > \\n
	작은따옴표 > \\‘
	큰따옴표 > \\“
	char는 유니코드가 저장되기 때문에 음수가 필요없다 따라서 2^16승인 0~65535까지의 수를 표현할 수 있다
	반대로 short는 음수도 표현해야하기 때문에 -32768~32768의 값을 범위로 갖는다.
4-3. 정수형
	정수형은 모두 4개의 자료형이 있다.
	변수에 저장하려는 정수값에 범위에 따라 선택하면 되겠지만 int를 사용하도록 하자 메모리를 조금 더 절약할 수는 있지만 값의 범위가 작은 범위라서 연산시에 범위를 넘으면 잘못된 결과를 얻기가 쉽다.
	또한 JVM의 피연산자 스택이 연산자를 4byte로 저장하기 때문에 4byte보다 작은 자료형의 값을 계산할 때는 4byte로 형변환을 실시한다. 그래서 int를 사용하는 것이 효율적이다.
	4 bit 2진수의 최대값인 1111에 1을 더하면 오버플로우가 생긴다. 하지만 에러는 발생하지 않는다. 다만 예상했던 결과를 얻지 못할 뿐이다.
	부호가 없는 변수는 0000일 때 오버플로우가 발생하며, 부호가 있는 변수는 MSB가 0에서 1이 되거나 1에서 0이 될 때 오버플로우가 발생한다.
4-4. 실수형
	실수형은 실수를 저장하기 위한 타입으로 2 개의 자료형이 있다.
	실수형은 정수형과 달리 저장범위를 넘어가면 오버플로우가 발생하지 않는다 대신 변수의 값은 무한대가 된다.
	정수형과 달리 대신 언더플로우라는 개념이 있는데 이것은 실수형으로 표현할 수 없는 아주 작은 값이 들어왔을 때 발생한다. 이 때 변수의 값은 0이 된다.
	float와 double은 변수의 크기보다는 정밀도로 사용방법이 나뉜다.
5-0. 형변환
5-1. 형변환이란?
	지금까지 변수와 리터럴에는 타입이 있다는 것을 배웠다.
	프로그램을 작성하다 보면 서로 다른 타입 간의 연산을 수행해야 하는 경우가 있다.
	이럴 때 다른 타입으로 변환하는 것을 형변환이라고 한다.
5-2. 형변환 방법
	형변환 방법은 아주 간단하다 리터럴 앞에 (타입)을 붙여주면 된다.
	기본형과 기본형의 형변환은 가능하다 기본형과 참조형간의 형변환은 불가능하다.
5-3. 정수형간의 형변환
	형변환을 할 때 큰 타입에서 작은 타입으로 형변환을 진행하면 값 손실이 일어나게 된다.
	작은 타입에서 큰 변환으로 형변환을 진행하면 값 손실은 일어나지 않고 남은 자릿수가 0으로 채워진다.
5-4. 실수형 간의 형변환
	실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우 빈 공간을 0으로 채운다.
5-5. 정수형과 실수형 간의 형변환
	정수형과 실수형은 저장방식이 완전히 때문에 복잡한 변환과정을 거쳐야한다.
	정수를 실수형으로 변환할 때는 소수점이 없기 때문에 변환이 간단하다.
	다만 실수형을 정수형으로 변환할 때 무리가 생긴다. Float의 정밀도는 7자리이므로 int형을 형변환 할 때 오차가 발생할 수 있다. 만일 7자리 이상을 형변환을 해야한다면 double로 하도록 하자.
	실수형을 정수형으로 형변환 할 때는 소수점 이하의 값을 다 버리기 때문에 반올림이 일어나지 않는다.
5-6. 자동 형변환
	서로 다른 타입간의 연산을 할 때 형변환으로 타입을 일치시키는게 원칙이다.
	허나 경우에 따라 생략할 수 있다. 컴파일러가 자동적으로 형변환을 추가한다.
	큰 타입의 변수에 타입이 작은 리터럴 값을 넣을 때에는 자동적으로 형변환이 일어나지만 반대의 경우에는 값 손실이 발생할 수 있다는 에러가 발생한다.
	그러나 명시적으로 형변환을 해줬을 경우에는 의도적인 것으로 간주해 에러메시지를 뱉지 않는다.
	char와 short의 경우 바이트는 2바이트로 같지만 표현할 수 있는 범위가 다르기 때문에 자동적으로 형변환이 이루어질 수 없다.

## Chapter 3
### 1. 연산자
+ 연산자는 연산을 수행하는 기호를 말한다.
+ 연산자는 피연산자(변수, 상수, 리터럴, 수식)와 연산자(기호)로 구분된다.
+ 연산자는 산술, 비교, 논리, 대입, 기타 연산자로 분류된다.
+ 식에 사용된 연산자가 둘 이상일 경우 우선순위에 의해서 순서가 결정된다.

> 1. 산술 > 비교> 논리> 대입, 대입은 제일 마지막에 수행된다.
> 2. 단항(1) > 이항(2) > 삼항(3), 단항 연산자의 우선순위가 높다.
> 3. 단항 연산자와 대입 연산자를 제외한 모든 연산은 왼쪽에서 오른쪽이다.

+ 피연산자의 타입이 서로 다르다면 형변환 연산자로 타입을 일치시켜야한다.
+ int와 float의 경우 타입을 둘 다 int 또는 float로 일치시켜야한다.
+ 작은 타입을 큰 타입으로 변환하는 경우 자동으로 형변환이 진행된다.
+ 자동으로 형변환 되는 과정을 ‘산술 변환’이라고 한다.

> 1. 두 피연산자의 타입을 같게 일치시킨다.
> 2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

### 2. 단항 연산자
#### 2-1. 증감 연산자
+ 증감연산자는 지정된 값을 1 증가 또는 감소시킨다.
+ 피연산자의 왼쪽에 있으면 prefix 오른쪽에 있으면 postfix라고 부른다.
+ prefix는 값이 참조되기 전에 변화하고 postfix는 참조된 후 변화한다.
+ 증감 연산자는 식에서 두 번 이상 사용하는 변수에는 사용하지 말아야한다.

#### 2-2. 부호 연산자
+ 부호 연산자는 부호를 반대로 변경한 결과를 반환한다.
+ Boolean형과 char형을 제외한 기본형에만 사용할 수 있다.

### 3. 산술 연산자
#### 3-1. 사칙 연산자
+ 사칙 연산자는 우리가 사용해오던 덧셈, 뺄셈, 나눗셈, 곱셈을 의미한다.
+ 정수를 정수로 나누었을 때는 몫만 계산결과가 나오기 때문에 주의해야한다.
``` java
Byte a = 10;
Byte b = 20;
Byte c = a + b;
System.out.println(c);
```
+ 이 경우 에러가 발생한다. Java는 int보다 작은 타입일 경우 int형으로 형변환을 한 후 작업을 처리하는데 int형의 a+b의 결과를 Byte에 저장하기 때문에 에러가 발생한다.
+ 사칙연산의 피 연산자로 숫자뿐만 아니라 문자도 가능하다.
``` java
Char c1 = ‘a’;
Char c2 = c1+1; // 에러 발생
Char c3 = ‘a’+1;
```
+ c3을 보면 분명 int보다 작은 타입의 연산에서는 int로 형변환 되어 연산이 수행된다고 했다 하지만 c3은 에러가 나지 않았다.
> c3은 리터럴 연산이기 때문이다. 리터럴 간의 연산은 실행과정동안 값이 변하는게 아니기 때문에 컴파일러가 컴파일 시에 계산 후 값을 대체해서 코드를 효율적으로 만들기 때문에 덧셈 연산이 수행되지 않아 오류가 발생하지 않는다.
> c2는 변수를 수식에 사용했기 때문에 변수는 컴파일러가 미리 계산을 할 수가 없어 형변환을 명시적으로 하지 않으면 에러가 발생한다.

#### 3-2. 나머지 연산자
+ 나머지 연산자는 음수로 나누는 것을 허용하지만 부호를 무시하기 때문에 결과는 부호에 상관이 없다.

### 4. 비교 연산자
+ 비교 연산자는 결과과 true false 둘 중 하나이며 비교하는 데 사용되는 연산자다.
#### 4-1. 대소비교 연산자 < > <= >=
+ 두 피연산자의 값의 크기를 비교하는 연산자이다.
+ Boolean 형을 제외한 자료형에 사용할 수 있지만 참조형에는 사용할 수 없다.
#### 4-2. 등가비교 연산자 == !=
+ 피연산자의 값이 같은지 비교하는 연산자이다. 
+ 기본형의 경우 값이 같은지를 알 수 있고
+ 참조형의 경우 객체의 주소가 같은지를 알 수 있다.
+ 문자열의 경우 값이 같은지 확인하려면 .equals() 메서드를 사용해야 한다.
+ 대소문자를 구별하지 않으려면 equalsIgnoreCase()를 사용해야 한다.
### 5. 논리 연산자
+ 두 개의 비교 연산자가 결합된 경우는 논리연산자를 사용해야 한다. AND, OR로 연결한다.
#### 5-1. 논리 연산자 - &&, ||, !
+ 논리 연산자의 특징은 효율적인 연산을 한다는 것이다.
+ OR 연산의 경우 두 피연산자의 값중 어느 한 쪽이라도 true라면 우측 피연산자의 값은 평가하지 않는다.
## Chapter 4

+ 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 제어문이라고 한다.
+ 제어문에는 조건문과 반복문이 있다.
### 1. 조건문 - if, switch
+ 조건문은 조건식과 문장을 포함하는 블럭으로 구성된다.
+ 주로 if 문이 많이 사용된다.
+ 처리할 경우의 수가 많으면 if문보다 switch문이 효율적이지만 제약이 많다.
#### 1.1. if문
+ 가장 기본적인 조건문이며 조건식과 괄호로 이루어져 있다.
+ 조건식의 결과는 반드시 true 또는 false여야 한다는 것을 잊지 말자.
+ 괄호를 이용해서 여러 문장을 하나로 묶을 수 있는데 이것을 블럭이라고 한다.
+ 문장이 하나인 경우에는 블럭을 생략할 수 있지만 가능하면 생략하지 않는 것이 바람직하다.
#### 1.2. if-else문
+ if 문에 else 블럭이 추가된 되었다.
+ 조건식의 결과가 참이 아닐 때 else 블럭의 문장을 수행하라는 뜻이다.

#### 1-3. If-else if문
+ 처리해야할 경우의 수가 셋 이상인 경우에 사용한다.
+ else문은 생략이 가능하다.
+ 참이 조건식을 만나면 해당 블럭의 문장들을 수행하고 전체를 빠져나온다.

#### 1-4. 중첩 if문
+ if문의 블럭 내에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라고 부른다.
+ 내부의 if문과 외부의 if문을 혼동하지 않게 괄호를 붙이도록 하자

#### 1-5. Switch문
+ if문은 조건식의 결과가 참과 거짓, 두 가지 밖에 없기 떄문에 조건이 추가되면 복잡해지고 처리시간도 많이 걸린다.
+ switch문은 단 하나의 조건식으로 경우의 수를 처리할 수가 있고 표현도 간결하다.
+ 하지만 제약조건이 있기 때문에, 경우의 수가 많아도 if문으로 작성해야 하는 경우가 있다.
+ switch문은 조건식을 먼저 계산한 후 그 결과와 일치하는 case문으로 이동한다.
+ break문을 만나면 전체 switch문을 빠져나가게 된다.
+ default문은 조건식의 결과가 일치하지 않을 때 작동하는건데 default문 내부에서는 break를 생략해도 된다. 다만, case문은 break이 없으면 구분이 없어지므로 빼먹는 실수를 하지 않도록 주의해야한다.
+ case문의 값은 정수, 상수만 가능하다.

### 2. 반복문 - for, while, do-while
+ 반목문은 어떤 작업이 반복적으로 수행되도록 할 때 사용되며, 반복문의 종류로는 for문이나 while문 그리고 while문의 변형인 do-while문이 있다.
+ for, while은 한 번도 수행이 안 될 수가 있지만 do-while문은 최소 한 번은 보장한다. 
+ for문이나 while은 구조와 기능이 유사하며 어느쪽을 선택해도 되지만 for문은 주로 반복횟수를 알고 있을 때 사용한다.

#### 2-1. for문
+ 증감식에는 쉼표를 사용하면 두 문장 이상을 하나로 연결해서 쓸 수 있다.
+ 조건식이 생략된 경우 참으로 간주되어 무한 반복문이 된다. 
+ jdk1.5부터 for문의 새로운 문법이 추가되었다.
``` java
For( 타입 변수명: 배열 또는 컬렉션){
	// 반복할 문장
}
```

+ 문법은 간결해졌으나 컬렉션이나 배열에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.

#### 2-2. while문
+ while문의 조건식은 생략할 수 없다.
+ 